/**
 *@file 1.cpp
 * @author your name (you@domain.com)
 * @brief 拥有默认实参的形参必须位于函数的右侧是最后一个形参或右侧也是是别的默认实参
 * @version 0.1
 * @date 2023-03-23
 *
 * @copyright Copyright (c) 2023
 *
 */

#include <iostream>

 /**
  * @brief 默认实参：允许调用函数时不提供一个或多个尾部的实参。
  *
  *     在函数声明中，所有在拥有默认实参的形参之后的形参必须：
  *         1.拥有在这个或同一作用域中先前的声明中所提供的默认实参
  *             除非该形参是从某个形参包展开得到的
  *         2.或者是函数形参包
  *
  *     默认实参只能在函数声明和 lambda 表达式的形参列表中出现，
  *     而不能在函数指针、到函数的引用，或在 typedef 声明中出现。
  *
  *     对于非模板函数，当在同一作用域中重声明函数时，可以向已声明的函数添加默认实参。
  *     在函数调用点，可用的默认实参是由该函数所有可见的声明中所提供的默认实参的并集。
  *     重声明不能为已有可见默认值的实参引入默认值（即使值相同）。
  *     内层作用域中的重声明不从外层作用域获得默认实参。(不同的代码块)
  *
  *     using 声明会将已知的默认实参集承接过来，且如果向函数的命名空间中添加更多默认形参，
  *     那么这些默认实参在这条using 声明可见的任何位置均可见
  *     对默认实参中使用的名字进行查找，检查可访问性，并在声明点绑定，但会在函数调用点才执行：
  *
  *     对于非模板类的成员函数，类外的定义中允许出现默认实参，并与类体内的声明所提供的默认实参组合。
  *     如果类外的默认实参会使成员函数变成默认构造函数或复制/移动 (C++11 起)构造函数/赋值运算符，那么程序非良构。
  *     对于类模板的成员函数，所有默认实参必须在成员函数的初始声明处提供。
  *
  *     虚函数的覆盖函数不会从基类定义获得默认实参，而在进行虚函数调用时，默认实参根据对象的静态类型确定
  *
  *     默认实参中不能使用潜在求值的局部变量,
  *     默认实参中不能使用 this 指针,
  *     默认实参中不能使用非静态的类成员（即使它们不被求值），除非用于构成成员指针或在成员访问表达式中使用,
  *     默认实参不是函数类型的一部分
  *
  *     除了函数调用运算符外()，运算符函数[]不能有默认实参
  *
  *
  */

  /**
   *@brief 情形1，按照顺序在声明中添加默认实参
   *
  */
void f(int, int, int = 10); //声明 已经给了第三个形参默认实参
void f(int, int = 6, int);  //声明 此时给第二个形参默认实参是可以接受的，但不能交换顺序
void f(int = 4, int, int);
void f(int a, int b, int c) { std::cout << a << ' ' << b << ' ' << c << '\n'; }

/**
 *@brief 情形2，特殊情况，函数参数包
 *
 */
template<class...T>
struct X {
    void f(int n = 0, T...) { std::cout << n << '\n'; };
};
template<class...Args>
void f_(int n = 6, Args...args) {

}

struct Base
{
    virtual void f(int a = 7) {
        std::cout << a << std::endl;
    };
};

struct Derived: Base
{
    void f(int a) override {
        std::cout << a << std::endl;
    };
};

void m()
{
    Derived d;
    Base& b = d;
    b.f(); // OK：调用 Derived::f(7) 
    //d.f(); // 错误：没有默认实参
}

int main() {

    {
        f();//在当前作用域提前给已经声明了默认实参的形参后面的形参默认实参
    }

    {
        X<>().f();
        X<int>().f(1, 2);//实例化了X::f(int n=0,int)
    }

    std::cout << "-------\n";
    m();

    std::cout << "-------\n";
    int x = 0;
    void f2(int n = sizeof(x));
    f2();

    return 0;
}

void f2(int n) {
    std::cout << n << '\n';
}
